# ps7_listener.ps1
param(
    [string]$Bind = '0.0.0.0',   # set to your LAN IP for restricted bind (e.g. 192.168.1.50)
    [int]$Port = 413,
    [string[]]$Allowlist = @()   # optional list of allowed client IPs (leave empty to allow any)
)

using namespace System.Net
using namespace System.Net.Sockets
using namespace System.Text
using namespace System.Threading
using namespace System.Threading.Tasks

function Write-Log { param($s) $ts = (Get-Date).ToString('yyyy-MM-dd HH:mm:ss'); Write-Host "$ts`t$s" }

# Resolve bind address
if ($Bind -eq '0.0.0.0') {
    $ip = [IPAddress]::Any
} else {
    $ip = [IPAddress]::Parse($Bind)
}

$listener = [TcpListener]::new($ip, $Port)
try {
    $listener.Start()
    Write-Log "LISTENER started on $Bind:$Port"
    Write-Log "Waiting for incoming connection..."
    $client = $listener.AcceptTcpClient()
    $remoteEP = $client.Client.RemoteEndPoint.ToString()
    $remoteIP = ($client.Client.RemoteEndPoint).Address.ToString()
    Write-Log "Connection from $remoteEP"

    if ($Allowlist -and $Allowlist.Count -gt 0) {
        if (-not ($Allowlist -contains $remoteIP)) {
            Write-Log "REJECT: $remoteIP not in allowlist. Closing."
            $client.Close(); return
        }
    }

    $stream = $client.GetStream()
    $enc = [Encoding]::UTF8
    $cts = [CancellationTokenSource]::new()
    $token = $cts.Token

    # Reader task: reads from network and writes immediate output to console
    $readerTask = [Task]::Run( {
        param($ns, $enc, $tok, $remoteEP)
        $buf = New-Object byte[] 8192
        try {
            while (-not $tok.IsCancellationRequested -and $ns.CanRead) {
                $read = $ns.ReadAsync($buf, 0, $buf.Length, $tok).GetAwaiter().GetResult()
                if ($read -le 0) { break }
                try {
                    $s = $enc.GetString($buf, 0, $read)
                } catch {
                    $s = [Text.Encoding]::ASCII.GetString($buf,0,$read)
                }
                # Write raw so incoming stream interleaves with prompt
                [Console]::Write($s)
            }
        } catch [OperationCanceledException] {
            # expected on cancellation
        } catch {
            # ignore other read errors (connection closed)
        } finally {
            # ensure newline so prompt is clean
            [Console]::WriteLine()
        }
    }, $stream, $enc, $token, $remoteEP)

    Write-Log "Interactive session ready. Type lines and press Enter to send. Type 'exit' to close."
    $writer = New-Object System.IO.StreamWriter($stream, $enc)
    $writer.AutoFlush = $true

    while ($client.Connected) {
        $line = [Console]::ReadLine()
        if ($null -eq $line) { break }             # EOF or console closed
        # send with CRLF so shells expecting newline behave
        try {
            $writer.WriteLine($line)
        } catch {
            Write-Log "Error sending: $($_.Exception.Message)"; break
        }
        if ($line -eq 'exit') {
            Write-Log "Operator requested exit. Closing."
            break
        }
    }

} catch {
    Write-Log "ERROR: $($_.Exception.Message)"
} finally {
    try { if ($cts) { $cts.Cancel() } } catch {}
    try { if ($readerTask) { $readerTask.Wait(1000) } } catch {}
    try { if ($stream) { $stream.Close(); $stream.Dispose() } } catch {}
    try { if ($client) { $client.Close() } } catch {}
    try { if ($listener) { $listener.Stop() } } catch {}
    Write-Log "Listener stopped/cleaned up."
}
